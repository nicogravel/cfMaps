
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>1.2. pRF fitting procedure using Braincoder &#8212; cfMaps  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="2. Connective Field Modelling" href="../connmaps/index.html" />
    <link rel="prev" title="1.1. Population Receptive Field (pRF) mapping" href="../vfm/retmaps.html" />
    <link href="../_static/style.css" rel="stylesheet" type="text/css">

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/logo.png" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">Research Log</p>






<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../vfm/index.html">1. Visual Field mapping</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../vfm/retmaps.html">1.1. <strong>Population Receptive Field (pRF) mapping</strong></a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">1.2. pRF fitting procedure using Braincoder</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../connmaps/index.html">2. Connectivity mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../refs.html">3. References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">4. Codebook</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../vfm/index.html"><span class="section-number">1. </span>Visual Field Mapping</a><ul>
      <li>Previous: <a href="../vfm/retmaps.html" title="previous chapter"><span class="section-number">1.1. </span><strong>Population Receptive Field (pRF) mapping</strong></a></li>
      <li>Next: <a href="../connmaps/index.html" title="next chapter"><span class="section-number">2. </span>Connective Field Modelling</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="../vfm/retmaps.html" title="Previous document"><span class="section-number">1.1. </span><strong>Population Receptive Field (pRF) mapping</strong></a>
        </li>
        <li>
          <a href="../connmaps/index.html" title="Next document"><span class="section-number">2. </span>Connective Field Modelling</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <section id="pRF-fitting-procedure-using-Braincoder">
<h1><span class="section-number">1.2. </span>pRF fitting procedure using Braincoder<a class="headerlink" href="#pRF-fitting-procedure-using-Braincoder" title="Permalink to this heading">Â¶</a></h1>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># Reinstall latest updates and restart kernel
!cd /home/nicolas-gravel/Documents/GitHubProjects/cfMaps/ &amp;&amp; pip install -e .
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Obtaining file:///home/nicolas-gravel/Documents/GitHubProjects/cfMaps
  Installing build dependencies ... done
  Checking if build backend supports build_editable ... done
  Getting requirements to build editable ... done
  Preparing editable metadata (pyproject.toml) ... done
Building wheels for collected packages: cfmap
  Building editable for cfmap (pyproject.toml) ... done
  Created wheel for cfmap: filename=cfmap-0.0.0-0.editable-py3-none-any.whl size=3757 sha256=1313e120a9cc1234c83cdcf4a2d3af52ff56fbfd3c3e64294f8cfc6c5d011b10
  Stored in directory: /tmp/pip-ephem-wheel-cache-2te1dzc2/wheels/a0/70/a8/75fa0900702ea99de0075946e4ff3d3c683c37649355fe66c2
Successfully built cfmap
Installing collected packages: cfmap
Successfully installed cfmap-0.0.0
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># Define subjects to process
#subject_ids = [&#39;02&#39;, &#39;03&#39;, &#39;05&#39;]
subject_ids = [&#39;02&#39;]
session_id = &#39;ses-01&#39;

# Data source configuration
data_source = &#39;remote&#39;  # Change this to &#39;local&#39; or &#39;remote&#39;

projType = &#39;surf-projected_projfrac&#39;
#projType = &#39;surf-projected_projdist-avg&#39;

# Define paths based on data source
if data_source == &#39;local&#39;:
    base_data_path = &#39;/media/user/External/XY/&#39;
    pRF_images_path = &#39;/home/user/Documents/data/XY/pRF_images/&#39;
elif data_source == &#39;remote&#39;:
    base_data_path = &#39;/media/user/Crucial/XY/&#39;
    pRF_images_path = &#39;/media/user/Crucial/XY/pRF_images&#39;
else:
    raise ValueError(&quot;data_source must be either &#39;local&#39; or &#39;remote&#39;&quot;)



# for fMRI data manipulation and basic data handling
import os
import sys
import glob
import math
import numpy as np
import scipy.stats as stats
import pandas as pd
import nibabel as nib
import neuropythy as ny
import ipyvolume as ipv
from PIL import Image
import matplotlib.pyplot as plt


# for pRF modeling
from numba import cuda
device = cuda.get_current_device()
device.reset()

import os
import tensorflow as tf

# Set this flag to False to use CPU instead of GPU
USE_GPU = True

if not USE_GPU:
    # Force TensorFlow to use CPU
    os.environ[&#39;CUDA_VISIBLE_DEVICES&#39;] = &#39;-1&#39;
    print(&quot;Running on CPU&quot;)
else:
    # Configure GPU memory growth to avoid memory issues
    gpus = tf.config.list_physical_devices(&#39;GPU&#39;)
    if gpus:
        try:
            for gpu in gpus:
                tf.config.experimental.set_memory_growth(gpu, True)
            # Use async memory allocator for better memory management
            os.environ[&quot;TF_GPU_ALLOCATOR&quot;] = &quot;cuda_malloc_async&quot;
            print(f&quot;Running on GPU: {gpus}&quot;)
        except RuntimeError as e:
            print(f&quot;GPU configuration error: {e}&quot;)
    else:
        print(&quot;No GPU devices found, falling back to CPU&quot;)
        os.environ[&#39;CUDA_VISIBLE_DEVICES&#39;] = &#39;-1&#39;

# Verify current device being used
print(f&quot;TensorFlow is using: {tf.config.get_visible_devices()}&quot;)
print(f&quot;Built with CUDA: {tf.test.is_built_with_cuda()}&quot;)



from braincoder.models import GaussianPRF2DWithHRF
from braincoder.hrf import SPMHRFModel
from braincoder.optimize import ParameterFitter

## For pRF map plotting
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
from matplotlib.patches import Wedge
from matplotlib.patches import Rectangle
import matplotlib.colors as mcolors

# Retmaps code
from cfmap.color_palettes import get_color_palettes
from cfmap.pRF_processing import plot_prf_histograms, plot_roi_retMap


# Load color palettes
color_palettes = get_color_palettes()
color_palettes = get_color_palettes()
colors_ecc = color_palettes[&quot;eccentricity&quot;]
colors_polar = color_palettes[&quot;polar&quot;]


# Create save path
base_save_path = os.path.join(base_data_path, &#39;pRF_results&#39;, projType)
os.makedirs(base_save_path, exist_ok=True)


# Create and visualize stimuli
data_list = [] # Initialize an empty list to store the data

# Loop through the files in the folder
for frame in range(150):
    # Load the .png file
    file_path = os.path.join(pRF_images_path,&#39;run5_&#39; + str(frame) + &#39;.png&#39;)
    image = Image.open(file_path)
    data = np.array(image)
    data_list.append(data)

# Stack the data along the third dimension to create the design matrix
design_matrix = np.stack(data_list, axis=-1)

print(f&#39;design matrix shape: {design_matrix.shape}&#39;)



# screen pRF stimulus parameters
screen_height_cm   = 69.4# 32 #39.29 #69.84 #12.65
screen_size_cm     = screen_height_cm/2
screen_distance_cm = 199 #5.0

# calculate max stim ecc
max_ecc = math.atan(screen_size_cm/screen_distance_cm)

print(&#39;max ecc in rad: &#39;, max_ecc)
max_ecc_deg        = round(math.degrees(max_ecc))
print(&#39;max ecc in deg: &#39;, max_ecc_deg)
screen_size_deg = max_ecc_deg
paradigm = np.transpose(design_matrix, (2, 0, 1))

x, y = np.meshgrid(np.linspace(-screen_size_deg/2, screen_size_deg/2, paradigm.shape[1]),
                    np.linspace(-screen_size_deg/2, screen_size_deg/2, paradigm.shape[2]))

grid_coordinates = pd.DataFrame(np.array([x.flatten(), y.flatten()]).T.astype(np.float32), columns=[&quot;x&quot;, &quot;y&quot;])
print(f&quot;paradigm shape: {paradigm.shape}&quot;)

def make_grid_parameters(min_ecc: float = 0.1,
                     max_ecc: float = 11,
                     min_size: float = 0.1,
                     max_size: float = 5,
                     nr_of_points: int = 40,):
    ecc = np.linspace(np.sqrt(min_ecc), np.sqrt(max_ecc), nr_of_points//2)**2
    sizes = np.linspace(min_size, max_size, nr_of_points)
    x = np.concatenate((-ecc[::-1], ecc))

    return {&#39;x&#39;:x, &#39;y&#39;:x, &#39;size&#39;:sizes}
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Running on GPU: [PhysicalDevice(name=&#39;/physical_device:GPU:0&#39;, device_type=&#39;GPU&#39;)]
TensorFlow is using: [PhysicalDevice(name=&#39;/physical_device:CPU:0&#39;, device_type=&#39;CPU&#39;), PhysicalDevice(name=&#39;/physical_device:GPU:0&#39;, device_type=&#39;GPU&#39;)]
Built with CUDA: True
design matrix shape: (150, 150, 150)
max ecc in rad:  0.17263612599950473
max ecc in deg:  10
paradigm shape: (150, 150, 150)
</pre></div></div>
</div>
<section id="Load-data-and-atlases-for-a-single-participant">
<h2><span class="section-number">1.2.1. </span>Load data and atlases for a single participant<a class="headerlink" href="#Load-data-and-atlases-for-a-single-participant" title="Permalink to this heading">Â¶</a></h2>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>subject_id = subject_ids[0]
session_id = &#39;ses-01&#39;



# Setup paths
subject_session_name = f&quot;sub-{subject_id}_{session_id}&quot;
fs_subject_path = os.path.join(base_data_path, subject_session_name, f&quot;{subject_session_name}_iso&quot;)
surf_atlas_path = os.path.join(fs_subject_path, &quot;surf&quot;)
save_path = os.path.join(base_data_path, subject_session_name)
pRF_params_path = os.path.join(base_data_path, &#39;pRF_results&#39;, projType, f&quot;sub-{subject_id}&quot;)

# Load necessary data
v1_centers = np.load(os.path.join(save_path, &quot;v1_centers.npy&quot;), allow_pickle=True).item()
v1_rights = np.load(os.path.join(save_path, &quot;v1_rights.npy&quot;), allow_pickle=True).item()

# Create subject and flatmaps
sub = ny.freesurfer_subject(fs_subject_path)
map_projs = {h: ny.map_projection(chirality=h,
                                center=v1_centers[h],
                                center_right=v1_rights[h],
                                method=&#39;orthographic&#39;,
                                radius=np.pi/2,
                                registration=&#39;native&#39;)
                for h in [&#39;lh&#39;, &#39;rh&#39;]}
flatmaps = {h: mp(sub.hemis[h]) for h, mp in map_projs.items()}



### Then we narrow down the vertices to just one hemisphere (and optionally to an ROI using the occipital atlas)

h = &#39;lh&#39;  # Change this to &#39;lh&#39; or &#39;rh&#39; as needed

# Get cortex index
cortex_index = flatmaps[h].prop(&#39;index&#39;)

# Load atlas maps
varea_map = nib.freesurfer.io.read_morph_data(
    os.path.join(surf_atlas_path, f&#39;{h}.benson14_varea.curv&#39;))[cortex_index]
sigma_map = nib.freesurfer.io.read_morph_data(
    os.path.join(surf_atlas_path, f&#39;{h}.benson14_sigma.curv&#39;))[cortex_index]
benson_eccen = nib.freesurfer.io.read_morph_data(
    os.path.join(surf_atlas_path, f&#39;{h}.benson14_eccen.curv&#39;))[cortex_index]
benson_polar = nib.freesurfer.io.read_morph_data(
    os.path.join(surf_atlas_path, f&#39;{h}.benson14_angle.curv&#39;))[cortex_index]
wang15_map = nib.freesurfer.io.read_morph_data(
    os.path.join(surf_atlas_path, f&#39;{h}.wang15.curv&#39;))[cortex_index]
</pre></div>
</div>
</div>
</section>
<section id="Select-small-atlas-based-ROI-to-test-the-pRF-fitting-workflow">
<h2><span class="section-number">1.2.2. </span>Select small atlas-based ROI to test the pRF fitting workflow<a class="headerlink" href="#Select-small-atlas-based-ROI-to-test-the-pRF-fitting-workflow" title="Permalink to this heading">Â¶</a></h2>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># Select source ROI and mask
roi_selection=[1]

#ecc_range=(0.75, 6.75)
ecc_range=(0, 6.5)



# Create mask for V1 (regions 0 and 1 in Wang atlas)
roi_mask = np.isin(wang15_map, [1, 2])  # V1v and V1d

## Use Benson eccentricity to narrow down the source ROI extent
param_mask = (benson_eccen &gt; ecc_range[0]) &amp; (benson_eccen &lt; ecc_range[1])
pol_mask =  (benson_polar &gt;= 35) &amp; (benson_polar &lt;= 135)
source_mask = roi_mask &amp; param_mask &amp; pol_mask


# Extract ROI submesh (and update vertex indices)
roi_submesh = flatmaps[h].submesh(source_mask)
roi_submesh.prop(&#39;index&#39;)
submesh_labels = roi_submesh.prop(&#39;label&#39;)
sub_source_mask = np.isin(flatmaps[h].labels, submesh_labels)



# Get the exact indices of your source vertices
source_indices = np.where(sub_source_mask)[0]
print(f&quot;Number of source vertices: {len(source_indices)}&quot;)

### V1 reference retinotopy from Benson atlas
plot_roi_retMap(benson_eccen, benson_polar, sub_source_mask, [&#39;Template eccentricity&#39;, &#39;Template polar angle&#39;], flatmaps, colors_ecc, colors_polar, h)
<br/><br/><br/></pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Number of source vertices: 863
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_pRF_modelling_7_1.png" src="../_images/notebooks_pRF_modelling_7_1.png" />
</div>
</div>
</section>
<section id="Load-training-data-and-test-the-workflow">
<h2><span class="section-number">1.2.3. </span>Load training data and test the workflow<a class="headerlink" href="#Load-training-data-and-test-the-workflow" title="Permalink to this heading">Â¶</a></h2>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>os.environ[&quot;TF_GPU_ALLOCATOR&quot;] = &quot;cuda_malloc_async&quot;

# Load time series data
ts_path = os.path.join(pRF_params_path, f&#39;{h}_averaged_cleaned_zscored.npy&#39;)

time_series = np.nan_to_num(np.load(ts_path))

train_data = time_series[sub_source_mask].T


del time_series

train_data.shape
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(150, 863)
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>###### pRF modeling #######

hrf_model = SPMHRFModel(tr=2, delay=4.5, dispersion=0.75)


model_gauss = GaussianPRF2DWithHRF(data=train_data,
                                    paradigm=paradigm,
                                    hrf_model=hrf_model,
                                    grid_coordinates=grid_coordinates)

###### Grid search #######

grid_min_ecc = 0.1
grid_max_ecc = 8
grid_min_sigma = 0.1
grid_max_sigma = 5
nr_of_gridfit_points = 20

grid_parameters = make_grid_parameters(min_ecc=grid_min_ecc,
                                            max_ecc=grid_max_ecc,
                                            min_size=grid_min_sigma,
                                            max_size=grid_max_sigma,
                                            nr_of_points=nr_of_gridfit_points)

par_fitter = ParameterFitter(model=model_gauss, data=train_data, paradigm=paradigm)

baseline = [0.0]
amplitude = [1.0]

pars_gauss_grid = par_fitter.fit_grid(grid_parameters[&#39;x&#39;],
                                        grid_parameters[&#39;y&#39;],
                                        grid_parameters[&#39;size&#39;],
                                        baseline,
                                        amplitude,
                                        correlation_cost=True)



###### Iterarive search (gtradient descent) #######

positive_amplitude = True
min_n_iterations = 400
max_n_iterations = 2000

# Fit baseline and amplitude

pars_gauss_ols = par_fitter.refine_baseline_and_amplitude(pars_gauss_grid,
                                                            positive_amplitude=positive_amplitude)
pars_gauss_gd = par_fitter.fit(init_pars=pars_gauss_ols,
                                min_n_iterations=min_n_iterations,
                                max_n_iterations=max_n_iterations)


# Now fit the pRF (2D Gaussian)
model_hrf = GaussianPRF2DWithHRF(data=train_data,
                                    paradigm=paradigm,
                                    hrf_model=hrf_model,
                                    grid_coordinates=grid_coordinates,
                                    flexible_hrf_parameters=True)

par_fitter_hrf = ParameterFitter(model=model_hrf, data=train_data, paradigm=paradigm)

# Then fit the HRF
# We set hrf_delay and hrf_dispersion to standard values
pars_gauss_gd[&#39;hrf_delay&#39;] = 4.5
pars_gauss_gd[&#39;hrf_dispersion&#39;] = 0.75

pars_gauss_hrf = par_fitter_hrf.fit(init_pars=pars_gauss_gd,
                                    min_n_iterations=min_n_iterations,
                                    max_n_iterations=max_n_iterations)

pars_gauss_hrf[&#39;r2&#39;] = par_fitter_hrf.get_rsq(pars_gauss_hrf)
<br/><br/></pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Working with chunk size of 5149
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
2025-10-16 14:21:27.666564: I external/local_xla/xla/stream_executor/cuda/cuda_executor.cc:998] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero. See more at https://github.com/torvalds/linux/blob/v6.0/Documentation/ABI/testing/sysfs-bus-pci#L344-L355
2025-10-16 14:21:27.670198: I external/local_xla/xla/stream_executor/cuda/cuda_executor.cc:998] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero. See more at https://github.com/torvalds/linux/blob/v6.0/Documentation/ABI/testing/sysfs-bus-pci#L344-L355
2025-10-16 14:21:27.673026: I external/local_xla/xla/stream_executor/cuda/cuda_executor.cc:998] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero. See more at https://github.com/torvalds/linux/blob/v6.0/Documentation/ABI/testing/sysfs-bus-pci#L344-L355
2025-10-16 14:21:27.809927: I external/local_xla/xla/stream_executor/cuda/cuda_executor.cc:998] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero. See more at https://github.com/torvalds/linux/blob/v6.0/Documentation/ABI/testing/sysfs-bus-pci#L344-L355
2025-10-16 14:21:27.812269: I external/local_xla/xla/stream_executor/cuda/cuda_executor.cc:998] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero. See more at https://github.com/torvalds/linux/blob/v6.0/Documentation/ABI/testing/sysfs-bus-pci#L344-L355
2025-10-16 14:21:27.813925: I tensorflow/core/common_runtime/gpu/gpu_process_state.cc:238] Using CUDA malloc Async allocator for GPU: 0
2025-10-16 14:21:27.814605: I external/local_xla/xla/stream_executor/cuda/cuda_executor.cc:998] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero. See more at https://github.com/torvalds/linux/blob/v6.0/Documentation/ABI/testing/sysfs-bus-pci#L344-L355
2025-10-16 14:21:27.816007: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1928] Created device /job:localhost/replica:0/task:0/device:GPU:0 with 4146 MB memory:  -&gt; device: 0, name: NVIDIA RTX 1000 Ada Generation Laptop GPU, pci bus id: 0000:01:00.0, compute capability: 8.9
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "ba3b2d33ca0c4104a2c799ba19b8d0fc", "version_major": 2, "version_minor": 0}</script></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
2025-10-16 14:21:30.711591: I external/local_xla/xla/stream_executor/cuda/cuda_dnn.cc:465] Loaded cuDNN version 8907
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
*** Fitting: ***
 * x
 * y
 * sd
 * baseline
 * amplitude
Number of problematic voxels (mask): 0
Number of voxels remaining (mask): 863
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
Current R2: 0.50381/Best R2: 0.50381: 100%|ââââââââââ| 2000/2000 [02:04&lt;00:00, 16.02it/s]
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
*** Fitting: ***
 * x
 * y
 * sd
 * baseline
 * amplitude
 * hrf_delay
 * hrf_dispersion
Number of problematic voxels (mask): 0
Number of voxels remaining (mask): 863
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
  0%|          | 0/2000 [00:00&lt;?, ?it/s]
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(1, 150, 863) (16, 863)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
Current R2: 0.70904/Best R2: 0.70904: 100%|ââââââââââ| 2000/2000 [02:11&lt;00:00, 15.20it/s]
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[31]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>x = pars_gauss_hrf[&#39;x&#39;]
y = pars_gauss_hrf[&#39;y&#39;]
sigma = pars_gauss_hrf[&#39;sd&#39;]
r2 = pars_gauss_hrf[&#39;r2&#39;]
baseline = pars_gauss_hrf[&#39;baseline&#39;]
amplitude = pars_gauss_hrf[&#39;amplitude&#39;]
hrf_delay = pars_gauss_hrf[&#39;hrf_delay&#39;]
hrf_dispersion = pars_gauss_hrf[&#39;hrf_dispersion&#39;]


# Calculate derived measures
ecc = np.abs(x + 1j*y)
polar = np.angle(x + 1j*y)



fig = plot_prf_histograms(
    ecc, polar, sigma, r2,
    bins=[200, 200, 200, 200],
    ylims=[(0, 40), (0, 40), (0, 200), (0, 60)],
    xlims=[(ecc_range[0], ecc_range[1]), (-np.pi/2, np.pi/2), (0, 1.5), (0, 1)],
    r2_threshold=0.0
)
plt.suptitle(&#39;Prediction grid optimization (residual sum of the squares)&#39;, fontsize=16, y=1.1)
plt.show()
<br/></pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_pRF_modelling_11_0.png" src="../_images/notebooks_pRF_modelling_11_0.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[33]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>## Plot pRF maps (eccentricity, polar angle, sigma and residual sum of the squares)

(fig, (left_ax, left_middle_ax, right_middle_ax, right_ax)) = plt.subplots(1, 4, figsize=(16, 4), dpi=72*4)

ecc_map = np.full(len(varea_map), np.nan)
ecc_map[sub_source_mask] = ecc
polar_map = np.full(len(varea_map), np.nan)
polar_map[sub_source_mask] = polar
sigma_map = np.full(len(varea_map), np.nan)
sigma_map[sub_source_mask] = sigma
r2_map = np.full(len(varea_map), np.nan)
r2_map[sub_source_mask] = r2


# Eccentricity
ny.cortex_plot(
    flatmaps[h],
    axes=left_ax,
    color=ecc_map,
    cmap=colors_ecc[&#39;matplotlib_cmap&#39;],
    mask=sub_source_mask,
    vmin=np.min(ecc_map[sub_source_mask]),
    vmax=np.max(ecc_map[sub_source_mask])/2
)

# Polar angle
ny.cortex_plot(
    flatmaps[h],
    axes=left_middle_ax,
    color=polar_map,
    cmap=colors_polar[&#39;matplotlib_cmap&#39;],
    mask=sub_source_mask
)

# Sigma (pRF size)
size_vmin = np.min(sigma_map[sub_source_mask])
size_vmax = np.max(sigma_map[sub_source_mask])
print(f&quot;Sigma range (masked): {size_vmin:.2f} - {size_vmax:.2f}&quot;)


sigma_max = 1.5
size_cmap = plt.cm.jet
m_sigma = ny.cortex_plot(
    flatmaps[h],
    axes=right_middle_ax,
    color=sigma_map,
    cmap=size_cmap,
    mask=sub_source_mask,
    vmin=np.min(sigma_map[sub_source_mask]),
    vmax=sigma_max #np.max(sigma_map[sub_source_mask])
)

# Variance explained
varex_cmap = plt.cm.inferno

m_varex = ny.cortex_plot(
    flatmaps[h],
    axes=right_ax,
    color=r2_map,
    cmap=varex_cmap,
    mask=sub_source_mask,
    vmin=0,
    vmax=1
)


# Legends/Inserts

# Eccentricity inset (concentric rings)
ecc_inset = inset_axes(
    left_ax,
    width=&quot;50%&quot;,
    height=&quot;50%&quot;,
    loc=&quot;lower right&quot;,
    borderpad=-6
)

ecc_inset.set_aspect(&#39;equal&#39;)
ecc_inset.set_xlim(-1.5, 1.5)
ecc_inset.set_ylim(-1.5, 1.5)
ecc_inset.text(0.5, -0.05, r&#39;$\mathit{r}\ (\mathit{deg})$&#39;, ha=&#39;center&#39;, va=&#39;top&#39;, fontsize=14, transform=ecc_inset.transAxes)
ecc_inset.set_axis_off()



num_ecc_colors = len(colors_ecc[&quot;hex&quot;])
for i, color in enumerate(colors_ecc[&quot;hex&quot;]):
    inner_r = i / num_ecc_colors
    outer_r = (i + 1) / num_ecc_colors
    ring = Wedge((0, 0), outer_r, 0, 360,
                    width=outer_r - inner_r,
                    color=color)
    ecc_inset.add_patch(ring)




# Polar angle inset (pie)
polar_inset = inset_axes(
    left_middle_ax,
    width=&quot;40%&quot;,
    height=&quot;40%&quot;,
    loc=&quot;lower right&quot;,
    borderpad=-6
)


polar_inset.set_aspect(&#39;equal&#39;)
polar_inset.set_axis_off()
polar_inset.pie(
    [1]*len(colors_polar[&quot;hex&quot;]),
    colors=colors_polar[&quot;hex&quot;],
    startangle=180,
    counterclock=False
)

polar_inset.text(0.5, -0.05, r&#39;$\theta\ (\mathit{rad})$&#39;, ha=&#39;center&#39;, va=&#39;top&#39;, fontsize=14, transform=polar_inset.transAxes)


# Sigma colorbar (standard scalar bar)
# Create a gradient rectangle

sigma_rect_ax = inset_axes(
    right_middle_ax,
    width=&quot;30%&quot;,
    height=&quot;10%&quot;,
    loc=&quot;lower right&quot;,
    borderpad=-3
)

gradient = np.linspace(0, 1, 256).reshape(1, -1)
gradient = np.vstack((gradient, gradient))

sigma_rect_ax.imshow(gradient, aspect=&#39;auto&#39;, cmap=size_cmap, extent=[0, 1, 0, 1])

#Add labels
sigma_rect_ax.text(0, -0.3, f&#39;{np.min(sigma_map[sub_source_mask]):.2f}&#39;, ha=&#39;left&#39;, va=&#39;top&#39;, fontsize=10)
sigma_rect_ax.text(1, -0.3, f&#39;{sigma_max:.2f}&#39;, ha=&#39;right&#39;, va=&#39;top&#39;, fontsize=10)
sigma_rect_ax.text(0.5, 1.3, r&#39;$\sigma\ (\mathit{deg})$&#39;, ha=&#39;center&#39;, va=&#39;bottom&#39;, fontsize=14, transform=sigma_rect_ax.transAxes)
sigma_rect_ax.axis(&#39;off&#39;)

# Varex colorbar (standard scalar bar)
varex_rect_ax = inset_axes(
    right_ax,
    width=&quot;30%&quot;,
    height=&quot;10%&quot;,
    loc=&quot;lower right&quot;,
    borderpad=-3
)

# Create gradient image
varex_rect_ax.imshow(gradient, aspect=&#39;auto&#39;, cmap=varex_cmap,
                        extent=[0, 1, 0, 1])
# Add labels
varex_rect_ax.text(0, -0.3, &#39;0&#39;, ha=&#39;left&#39;, va=&#39;top&#39;, fontsize=12)
varex_rect_ax.text(1, -0.3, &#39;1&#39;, ha=&#39;right&#39;, va=&#39;top&#39;, fontsize=12)
varex_rect_ax.text(0.5, 1.3, r&#39;$\mathit{r}\!{}^2$&#39;, ha=&#39;center&#39;, va=&#39;bottom&#39;, fontsize=14, transform=varex_rect_ax.transAxes)
varex_rect_ax.axis(&#39;off&#39;)


# Clean axes
left_ax.axis(&#39;off&#39;)
left_middle_ax.axis(&#39;off&#39;)
right_middle_ax.axis(&#39;off&#39;)
right_ax.axis(&#39;off&#39;)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Sigma range (masked): 0.13 - 6.09
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[33]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(-109.99794425569995,
 109.99814256987429,
 -109.99803380586756,
 109.99833891072826)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_pRF_modelling_12_2.png" src="../_images/notebooks_pRF_modelling_12_2.png" />
</div>
</div>
</section>
<section id="How-do-empirical-and-atlas-based-retinotopic-map-for-the-source-ROI-(V1)-compare?">
<h2><span class="section-number">1.2.4. </span>How do empirical and atlas based retinotopic map for the source ROI (V1) compare?<a class="headerlink" href="#How-do-empirical-and-atlas-based-retinotopic-map-for-the-source-ROI-(V1)-compare?" title="Permalink to this heading">Â¶</a></h2>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[34]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><br/><span></span># Map correlations
from scipy.stats import pearsonr
from pingouin import circ_corrcl

mask = sub_source_mask

ecc_pRF = ecc_map[mask]
pol_pRF = polar_map[mask]
ecc_atlas = benson_eccen[mask]
pol_atlas = np.deg2rad(benson_polar[mask] *2)-np.pi

# Compute circular correlation
corr_pol = circ_corrcl(pol_pRF, pol_atlas)
corr_pol_rho = corr_pol[0]
corr_pol_pval = corr_pol[1]

corr_ecc_rho, corr_ecc_pval = pearsonr(ecc_pRF, ecc_atlas)

print(&quot;\nPearson&#39;s rho (p-value) : &quot;, corr_ecc_rho,&#39;(&#39;,corr_ecc_pval,&#39;)&#39;)
print(&quot;\nCircular rho  (p-value) : &quot;, corr_pol_rho, &#39;(&#39;,corr_pol_pval,&#39;)&#39;)


# Scatter plots
fig, (ax_ecc, ax_pol) = plt.subplots(1, 2, figsize=(8, 4), dpi=200)

alpha = 0.5
scatter_size = 20

fig.suptitle(f&#39;pRF vs atlas -derived retinotopic selectivity in V1&#39;, fontsize=14, y=1)

ecc_color = &quot;#145A8C&quot;
pol_color = &quot;#9A1D1D&quot;

# Eccentricity scatter plot
ax_ecc.scatter(ecc_pRF, ecc_atlas, alpha=alpha, s=scatter_size, c=ecc_color)
max_ecc = np.ceil(max(ecc_pRF.max(), ecc_atlas.max()))
ax_ecc.plot([0, max_ecc], [0, max_ecc], &#39;k--&#39;, alpha=0.5)
ax_ecc.set_xlim(0, max_ecc)
ax_ecc.set_ylim(0, max_ecc)
ax_ecc.set_xlabel(&#39;pRF eccentricity (deg)&#39;, fontsize=14)
ax_ecc.set_ylabel(&#39;Atlas eccentricity (deg)&#39;, fontsize=14)
ax_ecc.text(0.95, 0.05, f&quot;Pearson&#39;s Ï={corr_ecc_rho:.2f}&quot;,
            ha=&#39;right&#39;, va=&#39;bottom&#39;, fontsize=14, transform=ax_ecc.transAxes)

# Polar angle scatter plot
ax_pol.scatter(pol_pRF, pol_atlas, alpha=alpha, s=scatter_size, c=pol_color)
ax_pol.plot([-np.pi, np.pi], [-np.pi, np.pi], &#39;k--&#39;, alpha=0.5)
ax_pol.set_xlim(-np.pi, np.pi)
ax_pol.set_ylim(-np.pi, np.pi)
ax_pol.set_xlabel(&#39;pRF polar angle (rad)&#39;, fontsize=14)
ax_pol.set_ylabel(&#39;Atlas polar angle (rad)&#39;, fontsize=14)
ax_pol.text(0.95, 0.05, f&quot;Circular Ï={corr_pol_rho:.2f}&quot;,
            ha=&#39;right&#39;, va=&#39;bottom&#39;, fontsize=14, transform=ax_pol.transAxes)

plt.tight_layout()
plt.show()
<br/></pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>

Pearson&#39;s rho (p-value) :  0.7484027220662547 ( 1.049164494247849e-155 )

Circular rho  (p-value) :  0.8231299928912087 ( 1.07090993936731e-127 )
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_pRF_modelling_14_1.png" src="../_images/notebooks_pRF_modelling_14_1.png" />
</div>
</div>
</section>
</section>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="../vfm/retmaps.html" title="Previous document"><span class="section-number">1.1. </span><strong>Population Receptive Field (pRF) mapping</strong></a>
        </li>
        <li>
          <a href="../connmaps/index.html" title="Next document"><span class="section-number">2. </span>Connective Field Modelling</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;.
      
      |
      <a href="../_sources/notebooks/pRF_modelling.ipynb.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>